# データ構造
データ構造に関するアルゴリズム
# Union Find

## Union Find
二つのノードが同じグループに属するかを判別する。共通の親を持つなら同じグループ。速い（アッカーマン関数の逆関数A(x)オーダー）。いろんなアルゴリズムの補助に使われたりする。

### 計算量
- N：ノード数

O(A(N))

## 重み付きUnion Find
親との距離を持っておくことで、同じ木に属するノード同士の距離を測ることができる。木を合わせるときに親との相対的な重みを更新、同じ木同士のときは重みを計算できる。

### 計算量
- N：ノード数

O(A(N))

# Segment Tree

## Segment Tree
完全二分木を用いて数列の部分和を高速で計算する。一度O(N)で初期化すれば、更新、計算がO(logN)でできる。

### 計算量
- N：ノード数

#### 初期化
O(N)

#### 更新・計算
O(logN)

## RMQ
Range Minimum Query。Segment Treeを用いて区間の最小の値をO(logN)で計算できる。
### 計算量
- N：ノード数

#### 初期化
O(N)

#### 更新・計算
O(logN)

# BIT
## BIT 部分和
BITを用いて区間の部分和を求める。1回の更新、取得それぞれがO(logN)で実行できるので早い。k += k&-kは1になっている最小位を求めるもの。

### 計算量
- N：数列の長さ、最大値など

#### 初期化
O(N)

#### 更新・計算
O(logN)

## BIT 最大値
BITで数列のそれ以前の部分の最大値を保持する。更新する時に今の値よりも小さくなると狂うことがあるので、そういうケースではSegment Treeを使う方がいい。

### 計算量
- N；数列の長さ

#### 初期化
O(N)

#### 更新・取得
O(logN)

## 転倒数
BITを用いて転倒数を計算する。転倒数とは、ある数列と目標とする数列との順列の差で、バブルソートの交換回数と一致する。バブルソートを愚直に計算するとO(N^2)かかるが、BITを用いてO(NlogN)にすることができる。

### 計算量
- N：数列の長さ

O(NlogN)

# Others

## LCA
木の二つのノードのLowest Common Ancestor、共通のもっとも深くにある親を見つける。直感的には枝分かれしたポイントを探す。LCAは一方のノードにもなりうる。あるノードの1つ上のノードを記憶するようにすると高速で2つ上のノードも見れる。これにより2^k先のノードを高速で参照できるようになるので、あるノードのN個上のノードはO(logN)で確認できる。

### 計算量
- N：ノード数
#### 前処理
O(NlogN)
#### クエリ
O(logN)
