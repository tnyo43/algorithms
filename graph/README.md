# Graph Algorithms

# 最短路

グラフのS地点からT地点まで最短のコストで行く探索。
最大コストを知りたいときは-1かけたりする。よくオーバーフローするので制約に気をつけるか無難にlong longを使う。

## Warshall Floyd
N個のノードのエッジをN×Nの2次元配列に保存する。a→bよりa→c→bの方が早い時に更新する。更新をN回行うと全てが最短路のコストになっていることが保証されている。
一回更新が終わるとそれ以降は参照するだけなので、スタート地点がわからないときはダイクストラよりも早いことがある。（使用例はそれ）

### 計算量
- V：ノードの数

O(V^3)

## Dijkstra
注目している点から他のノードに行くとき、更新できるならその点を優先度付きキューに保存する。コストの小さいものから順に注目していくので、
キューがからになるまで更新を繰り返すと最短経路が見つかる。多分一番早い。ただし悲負数限定。

### 計算量
- V：ノードの数
- E：エッジの数

O((E+V)logV)

## Bellman Ford
コストに負数があっても対応できる。N-1回の更新で全てのノードに着く最小コストが計算できる。
ただし、延々とコストが小さくなるループが存在するときは更新が終わらず、これも検知することができる。

### 計算量
- V：ノードの数
- E：エッジの数

O(EV)

# 最大流量
二つのノードs、tの間に複数の道があり、それらを使って通れる最大値を求める問題。追加する辺の片方の容量を0にすると有向グラフ、両方に容量をcをつけると無向グラフになる。

## Ford Fulkerson法
目的地まで目的地までの道があれば流せるだけ流し、その分だけエッジの容量を小さくする。そのかわりに逆方向への容量を大きくする。これで常に最大流に達するための経路を確保できる。目的地への道がなくなるまで繰り返し、それまでの流量の合計が最大流量となる。使用例では辺の両方に容量をつけて無向グラフにしてある。

### 計算量
- E：エッジの数
- F：最大フロー

O(EF)

## Dinic法
基本的にはFord Fulkerson法と同じ。先にBFSで出発地点からの距離を求めて無駄な遠回りをしないように改善されている。最大流量の見立てが大きい時にはFord Fulkerson法よりもこっちの方がいい気がする。使用例の二つ目は、要素を二つの状態に分け、コストを最大化する最小カットの使い方をしている。

##### 計算量
- V：ノードの数
- E：エッジの数

O(EV^2)

# グラフ理論

## 二部グラフ判定
ネットワークが二部グラフかどうかを判定する。DFSを用いて判定する。二部グラフでないときは-1、二部グラフのときは片方のグループのノード数を返すので、他方は全体から引くことで得られる。

### 計算量
- V：ノードの数

O(V)

## 二部マッチング
最大中問題を解くことで最大二部マッチングを行う。

### 計算量
- V：ノードの数
- E：エッジの数

O(V(V+E))

## ループ検出
ループを含む有向グラフのループが発生する箇所とループの長さを求める。2つのアクタ（うさぎと亀）はそれぞれ速度2、1で動かし、衝突する場所を探す。また、ループを一周してその場所に戻るまでのステップ数でループの長さがわかる

### 計算量
- V：ノード数

O(V)

# 最小全域木

## クラスカル法
グラフの全ての頂点を含む木のうち、辺の重みの総和が最小の物を求める。

### 計算量
- V：ノードの数
- E：エッジの数

O(E log(V+E))