# Graph Algorithms

## 最短路

グラフのS地点からT地点まで最短のコストで行く探索。
最大コストを知りたいときは-1かけたりする。よくオーバーフローするので制約に気をつけるか無難にlong longを使う。

### Warshall Floyd
N個のノードのエッジをN*Nの2次元配列に保存する。a→bよりa→c→bの方が早い時に更新する。更新をN回行うと全てが最短路のコストになっていることが保証されている。
一回更新が終わるとそれ以降は参照するだけなので、スタート地点がわからないときはダイクストラよりも早いことがある。（使用例はそれ）

#### 計算量　
- V：ノードの数

O(V^3)

#### 使用例　
[AtCoder ABC012 D バスと避けられない運命](https://beta.atcoder.jp/contests/abc012/submissions/3187821)

## Dijkstra
注目している点から他のノードに行くとき、更新できるならその点を優先度付きキューに保存する。コストの小さいものから順に注目していくので、
キューがからになるまで更新を繰り返すと最短経路が見つかる。多分一番早い。ただし悲負数限定。

### 計算量
- V：ノードの数
- E:エッジの数

O((E+V)logV)

### 使用例
[AtCoder ABC012 D バスと避けられない運命](https://beta.atcoder.jp/contests/abc012/submissions/3187768)

## Bellman Ford
コストに負数があっても対応できる。N-1回の更新で全てのノードに着く最小コストが計算できる。
ただし、延々とコストが小さくなるループが存在するときは更新が終わらず、これも検知することができる。

### 計算量
- V：ノードの数
- E:エッジの数

O(EV)

### 使用例
[AtCoder ABC061 D Score Attack](https://beta.atcoder.jp/contests/abc061/submissions/3189628)
